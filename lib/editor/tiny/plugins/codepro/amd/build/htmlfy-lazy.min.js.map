{"version":3,"file":"htmlfy-lazy.min.js","sources":["../src/htmlfy-lazy.js"],"sourcesContent":["\n/** @ts-ignore */\n/* eslint-disable */\n\n/**\n * @type {import('htmlfy').Config}\n */\nconst CONFIG = {\n  content_wrap: 0,\n  ignore: [],\n  ignore_with: '!i-£___£%_',\n  strict: false,\n  tab_size: 2,\n  tag_wrap: 0,\n  trim: []\n};\n\nconst VOID_ELEMENTS = [\n  'area', 'base', 'br', 'col', 'embed', 'hr', \n  'img', 'input', 'link', 'meta',\n  'param', 'source', 'track', 'wbr'\n];\n\n/**\n * Defined by state.js and configuration.\n * \n * CONTENT_IGNORE_PLACEHOLDER\n * SELF_CLOSING_PLACEHOLDER\n * ATTRIBUTE_IGNORE_PLACEHOLDER\n */\n\n/**\n * @typedef {object} Constants\n * @property {string} CONTENT_IGNORE_PLACEHOLDER\n * @property {string} SELF_CLOSING_PLACEHOLDER\n * @property {string} ATTRIBUTE_IGNORE_PLACEHOLDER\n */\n/**\n * @typedef {object} State\n * @property {boolean} checked_html - If passed in HTML has been checked for HTML within it.\n * @property {import(\"htmlfy\").Config} config - Validated configuration.\n * @property {boolean} ignored\n * @property {Constants} constants - Constant strings, influenced by ignore_with.\n */\n\n/**\n * @type State\n * \n * `constants` prefixes and suffixes must be in sync with those in utils.js\n */\nconst state = {\n  checked_html: false,\n  config: { ...CONFIG },\n  ignored: false,\n  constants: {\n    CONTENT_IGNORE_PLACEHOLDER: `${CONFIG.ignore_with}_`,\n    SELF_CLOSING_PLACEHOLDER: `${CONFIG.ignore_with}/_>`,\n    ATTRIBUTE_IGNORE_PLACEHOLDER: `${CONFIG.ignore_with}=_`\n  }\n};\n\n/**\n * \n * @returns {State}\n */\nconst getState = () => state;\n\n/**\n * \n * @param {Partial<State>} new_state \n */\nconst setState = (new_state) => Object.assign(state, new_state);\n\n/**\n * Checks if content contains at least one HTML element or custom HTML element.\n * \n * The first regex matches void and self-closing elements.\n * The second regex matches normal HTML elements, plus they can have a namespace.\n * The third regex matches custom HTML elemtns, plus they can have a namespace.\n * \n * HTML elements should begin with a letter, and can end with a letter or number.\n * \n * Custom elements must begin with a letter, and can end with a letter, number,\n * hyphen, underscore, or period. However, all letters must be lowercase.\n * They must have at least one hyphen, and can only have periods and underscores if there is a hyphen.\n * \n * These regexes are based on\n * https://w3c.github.io/html-reference/syntax.html#tag-name\n * and\n * https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\n * respectively.\n * \n * @param {string} content Content to evaluate.\n * @returns {boolean} A boolean.\n */\nconst isHtml = (content) => {\n  setState({ checked_html: true });\n\n  return /<(?:[A-Za-z]+[A-Za-z0-9]*)(?:\\s+.*?)*?\\/{0,1}>/.test(content) ||\n  /<(?<Element>(?:[A-Za-z]+[A-Za-z0-9]*:)?(?:[A-Za-z]+[A-Za-z0-9]*))(?:\\s+.*?)*?>(?:.|\\n)*?<\\/{1}\\k<Element>>/.test(content) || \n  /<(?<Element>(?:[a-z][a-z0-9._]*:)?[a-z][a-z0-9._]*-[a-z0-9._-]+)(?:\\s+.*?)*?>(?:.|\\n)*?<\\/{1}\\k<Element>>/.test(content)\n};\n\n/**\n * Generic utility which merges two objects.\n * \n * @param {any} current Original object.\n * @param {any} updates Object to merge with original.\n * @returns {any}\n */\nconst mergeObjects = (current, updates) => {\n  if (!current || !updates)\n    throw new Error(\"Both 'current' and 'updates' must be passed-in to mergeObjects()\")\n\n  /**\n   * @type {any}\n   */\n  let merged;\n  \n  if (Array.isArray(current)) {\n    merged = structuredClone(current).concat(updates);\n  } else if (typeof current === 'object') {\n    merged = { ...current };\n    for (let key of Object.keys(updates)) {\n      if (typeof updates[key] !== 'object') {\n        merged[key] = updates[key];\n      } else {\n        /* key is an object, run mergeObjects again. */\n        merged[key] = mergeObjects(merged[key] || {}, updates[key]);\n      }\n    }\n  }\n\n  return merged\n};\n\n/**\n * Merge a user config with the default config.\n * \n * @param {import('htmlfy').Config} default_config The default config.\n * @param {import('htmlfy').UserConfig} config The user config.\n * @returns {import('htmlfy').Config}\n */\nconst mergeConfig = (default_config, config) => {\n  const validated_config = mergeObjects(default_config, config);\n\n  /* Below `constants` prefixes and suffixes must be in sync with those in state.js */\n  setState({ \n    config: validated_config,\n    constants: {\n      CONTENT_IGNORE_PLACEHOLDER: `${validated_config.ignore_with}_`,\n      SELF_CLOSING_PLACEHOLDER: `${validated_config.ignore_with}/_>`,\n      ATTRIBUTE_IGNORE_PLACEHOLDER: `${validated_config.ignore_with}=_`\n    }\n  });\n  return validated_config\n};\n\n/**\n * \n * @param {string} html \n */\nconst protectAttributes = (html) => {\n  const { constants } = getState();\n\n  html = html.replace(/<[\\w:\\-]+([^>]*[^\\/])>/g, (/** @type {string} */match, /** @type {any} */capture) => {\n    return match.replace(capture, (match) => {\n      return match\n        .replace(/\\n/g, constants.ATTRIBUTE_IGNORE_PLACEHOLDER + 'nl!')\n        .replace(/\\r/g, constants.ATTRIBUTE_IGNORE_PLACEHOLDER + 'cr!')\n        .replace(/\\s/g, constants.ATTRIBUTE_IGNORE_PLACEHOLDER + 'ws!')\n    })\n  });\n\n  return html\n};\n\n/**\n * \n * @param {string} html \n */\nconst protectContent = (html) => {\n  const { constants } = getState();\n\n  return html\n    .replace(/\\n/g, constants.CONTENT_IGNORE_PLACEHOLDER + 'nl!')\n    .replace(/\\r/g, constants.CONTENT_IGNORE_PLACEHOLDER + 'cr!')\n    .replace(/\\s/g, constants.CONTENT_IGNORE_PLACEHOLDER + 'ws!')\n};\n\n/**\n * \n * @param {string} html \n */\nconst finalProtectContent = (html) => {\n  const regex = /\\s*<([a-zA-Z0-9:-]+)[^>]*>\\n\\s*<\\/\\1>(?=\\n[ ]*[^\\n]*__!i-£___£%__[^\\n]*\\n)(\\n[ ]*\\S[^\\n]*\\n)|<([a-zA-Z0-9:-]+)[^>]*>(?=\\n[ ]*[^\\n]*__!i-£___£%__[^\\n]*\\n)(\\n[ ]*\\S[^\\n]*\\n\\s*)<\\/\\3>/g; \n  const { constants } = getState();\n\n  return html\n    .replace(regex, (/** @type {string} */match, p1, p2, p3, p4) => {\n      const text_to_protect = p2 || p4;\n\n      if (!text_to_protect)\n        return match\n\n      const protected_text = text_to_protect\n       .replace(/\\n/g, constants.CONTENT_IGNORE_PLACEHOLDER + 'nl!')\n       .replace(/\\r/g, constants.CONTENT_IGNORE_PLACEHOLDER + 'cr!')\n       .replace(/\\s/g, constants.CONTENT_IGNORE_PLACEHOLDER + \"ws!\");\n\n      return match.replace(text_to_protect, protected_text)\n    })\n};\n\n/**\n * Replace html brackets with ignore string.\n * \n * @param {string} html \n * @returns {string}\n */\nconst setIgnoreAttribute = (html) => {\n  const regex = /<([A-Za-z][A-Za-z0-9]*|[a-z][a-z0-9._]*-[a-z0-9._-]+)((?:\\s+[A-Za-z0-9_-]+=\"[^\"]*\"|\\s*[a-z]*)*)>/g; \n  const { constants } = getState();\n\n  html = html.replace(regex, (/** @type {string} */match, p1, p2) => {\n    return match.replace(p2, (match) => {\n      return match\n        .replace(/</g, constants.ATTRIBUTE_IGNORE_PLACEHOLDER + 'lt!')\n        .replace(/>/g, constants.ATTRIBUTE_IGNORE_PLACEHOLDER + 'gt!')\n    })\n  });\n  \n  return html\n};\n\n/**\n * Trim leading and trailing whitespace characters.\n * \n * @param {string} html\n * @param {string[]} trim\n * @returns {string}\n */\nconst trimify = (html, trim) => {\n  for (let e = 0; e < trim.length; e++) {\n    /* Whitespace character must be escaped with '\\' or RegExp() won't include it. */\n    const leading_whitespace = new RegExp(`(<${trim[e]}[^>]*>)\\\\s+`, \"g\");\n    const trailing_whitespace = new RegExp(`\\\\s+(</${trim[e]}>)`, \"g\");\n\n    html = html\n      .replace(leading_whitespace, '$1')\n      .replace(trailing_whitespace, '$1');\n  }\n\n  return html\n};\n\n/**\n * \n * @param {string} html \n */\nconst unprotectAttributes = (html) => {\n  const { constants } = getState();\n\n  html = html.replace(/<[\\w:\\-]+([^>]*[^\\/])>/g, (/** @type {string} */match, /** @type {any} */capture) => {\n    return match.replace(capture, (match) => {\n      return match\n        .replace(new RegExp(constants.ATTRIBUTE_IGNORE_PLACEHOLDER + 'nl!', \"g\"), '\\n')\n        .replace(new RegExp(constants.ATTRIBUTE_IGNORE_PLACEHOLDER + 'cr!', \"g\"), '\\r')\n        .replace(new RegExp(constants.ATTRIBUTE_IGNORE_PLACEHOLDER + 'ws!', \"g\"), ' ')\n    })\n  });\n\n  return html\n};\n\n/**\n * \n * @param {string} html \n */\nconst unprotectContent = (html) => {\n  const { constants } = getState();\n\n  html = html.replace(new RegExp(`.*${constants.CONTENT_IGNORE_PLACEHOLDER}[a-z]{2}!.*`, \"g\"), (/** @type {string} */match) => {\n    return match.replace(new RegExp(`${constants.CONTENT_IGNORE_PLACEHOLDER}[a-z]{2}!`, \"g\"), (match) => {\n      return match\n        .replace(new RegExp(constants.CONTENT_IGNORE_PLACEHOLDER + 'nl!', \"g\"), '\\n')\n        .replace(new RegExp(constants.CONTENT_IGNORE_PLACEHOLDER + 'cr!', \"g\"), '\\r')\n        .replace(new RegExp(constants.CONTENT_IGNORE_PLACEHOLDER + 'ws!', \"g\"), ' ')\n    })\n  });\n\n  return html\n};\n\n/**\n * Replace ignore string with html brackets.\n * \n * @param {string} html \n * @returns {string}\n */\nconst unsetIgnoreAttribute = (html) => {\n  /* Regex to find opening tags and capture their attributes. */\n  const tagRegex = /<([\\w:\\-]+)([^>]*)>/g;\n  const { constants } = getState();\n  const escapedIgnoreString = constants.ATTRIBUTE_IGNORE_PLACEHOLDER.replace(\n    /[-\\/\\\\^$*+?.()|[\\]{}]/g,\n    \"\\\\$&\"\n  );\n  const ltPlaceholderRegex = new RegExp(escapedIgnoreString + \"lt!\", \"g\");\n  const gtPlaceholderRegex = new RegExp(escapedIgnoreString + \"gt!\", \"g\");\n\n  return html.replace(\n    tagRegex,\n    (\n      /** @type {string} */ fullMatch,\n      /** @type {string} */ tagName,\n      /** @type {string} */ attributesCapture\n    ) => {\n      const processedAttributes = attributesCapture\n        .replace(ltPlaceholderRegex, \"<\")\n        .replace(gtPlaceholderRegex, \">\");\n\n      /* Reconstruct the tag. */\n      return `<${tagName}${processedAttributes}>`\n    }\n  )\n};\n\n/**\n * Validate any passed-in config options and merge with CONFIG.\n * \n * @param {import('htmlfy').UserConfig} config A user config.\n * @returns {import('htmlfy').Config} A validated config.\n */\nconst validateConfig = (config) => {\n  if (typeof config !== 'object') throw new Error('Config must be an object.')\n  \n  const default_config = { ...CONFIG };\n\n  const config_empty = !(\n    Object.hasOwn(config, 'content_wrap') ||\n    Object.hasOwn(config, 'ignore') || \n    Object.hasOwn(config, 'ignore_with') || \n    Object.hasOwn(config, 'strict') || \n    Object.hasOwn(config, 'tab_size') || \n    Object.hasOwn(config, 'tag_wrap') || \n    Object.hasOwn(config, 'trim')\n  );\n\n  if (config_empty) {\n    setState({ config: default_config });\n    return default_config\n  }\n\n  let tab_size = config.tab_size;\n\n  if (tab_size) {\n    if (typeof tab_size !== 'number') throw new Error(`tab_size must be a number, not ${typeof config.tab_size}.`)\n\n    const safe = Number.isSafeInteger(tab_size);\n    if (!safe) throw new Error(`Tab size ${tab_size} is not safe. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger for more info.`)\n\n    /** \n     * Round down, just in case a safe floating point,\n     * like 4.0, was passed.\n     */\n    tab_size = Math.floor(tab_size);\n    if (tab_size < 1 || tab_size > 16) throw new Error('Tab size out of range. Expecting 1 to 16.')\n  \n    config.tab_size = tab_size;\n  }\n\n  if (Object.hasOwn(config, 'content_wrap') && typeof config.content_wrap !== 'number')\n    throw new Error(`content_wrap config must be a number, not ${typeof config.content_wrap}.`)\n\n  if (Object.hasOwn(config, 'ignore') && (!Array.isArray(config.ignore) || !config.ignore?.every((e) => typeof e === 'string')))\n    throw new Error('Ignore config must be an array of strings.')\n\n  if (Object.hasOwn(config, 'ignore_with')) {\n    if (typeof config.ignore_with !== 'string')\n      throw new Error(`ignore_with must be a string, not ${typeof config.ignore_with}.`)\n    else if (config.ignore_with.startsWith('_'))\n      /**\n       * This negatively affects processing of preserved tag attributes,\n       * because tag names can end with an underscore, so the regex\n       * does not capture them.\n       */\n      throw new Error(`ignore_with cannot start with an underscore.`)\n  }\n\n  if (Object.hasOwn(config, 'strict') && typeof config.strict !== 'boolean')\n    throw new Error(`Strict config must be a boolean, not ${typeof config.strict}.`)\n  \n  if (Object.hasOwn(config, 'tag_wrap') && typeof config.tag_wrap !== 'number')\n    throw new Error(`tag_wrap config must be a number, not ${typeof config.tag_wrap}.`)\n\n  if (Object.hasOwn(config, 'trim') && (!Array.isArray(config.trim) || !config.trim?.every((e) => typeof e === 'string')))\n    throw new Error('Trim config must be an array of strings.')\n\n  return mergeConfig(default_config, config)\n\n};\n\n/**\n * \n * @param {string} text \n * @param {number} width \n * @param {string} indent\n */\nconst wordWrap = (text, width, indent) => {\n  const words = text.trim().split(/\\s+/);\n  \n  if (words.length === 0 || (words.length === 1 && words[0] === ''))\n    return \"\"\n\n  const lines = [];\n  let current_line = \"\";\n  const padding_string = indent;\n\n  words.forEach((word) => {\n    if (word === \"\") return\n\n    if (word.length >= width) {\n      /* If there's content on the current line, push it first with correct padding. */\n      if (current_line !== \"\")\n        lines.push(lines.length === 0 ? indent + current_line : padding_string + current_line);\n\n      /* Push a long word on its own line with correct padding. */\n      lines.push(lines.length === 0 ? indent + word : padding_string + word);\n      current_line = \"\"; // Reset current line\n      return // Move to the next word\n    }\n\n    /* Check if adding the next word exceeds the wrap width. */\n    const test_line = current_line === \"\" ? word : current_line + \" \" + word;\n\n    if (test_line.length <= width) {\n      current_line = test_line;\n    } else {\n      /* Word doesn't fit, finish the current line and push it. */\n      if (current_line !== \"\") {\n         /* Add padding based on whether it's the first line added or not. */\n         lines.push(lines.length === 0 ? indent + current_line : padding_string + current_line);\n      }\n      /* Start a new line with the current word. */\n      current_line = word;\n    }\n  });\n\n  /* Add the last remaining line with appropriate padding. */\n  if (current_line !== \"\")\n    lines.push(lines.length === 0 ? indent + current_line : padding_string + current_line);\n\n  const result = lines.join(\"\\n\");\n\n  return protectContent(result)\n};\n\n/**\n * Extract any HTML blocks to be ignored,\n * and replace them with a placeholder\n * for re-insertion later.\n * \n * @param {string} html \n * @returns {{ html_with_markers: string, extracted_map: Map<any,any> }}\n */\nfunction extractIgnoredBlocks(html) {\n  setState({ ignored: true });\n  const config = (getState()).config;\n  let current_html = html;\n  const extracted_blocks = new Map();\n  let marker_id = 0;\n  const MARKER_PREFIX = \"___HTMLFY_SPECIAL_IGNORE_MARKER_\";\n\n  for (const tag of config.ignore) {\n    /* Ensure tag is escaped if it can contain regex special chars. */\n    const safe_tag_name = tag.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n\n    const regex = new RegExp(\n      `(<\\\\s*${safe_tag_name}[^>]*>)(.*?)(<\\\\s*\\/\\\\s*${safe_tag_name}\\\\s*>)`,\n      \"gs\" // global and dotAll\n    );\n\n    /** @type RegExpExecArray | null */\n    let match;\n\n    /**\n     * @type {{ start: number; end: number; marker: string }[]}\n     */\n    const replacements = [];\n\n    while ((match = regex.exec(current_html)) !== null) {\n      const marker = `${MARKER_PREFIX}${marker_id++}___`;\n\n      /* Only store content, and minify tags later. */\n      extracted_blocks.set(marker, match[2]);\n      \n      replacements.push({\n        start: match.index + match[1].length, // start of content\n        end: match.index + match[1].length + match[2].length, // end of content\n        marker: marker,\n      });\n    }\n\n    /* Apply replacements from the end to the beginning to keep indices valid. */\n    for (let i = replacements.length - 1; i >= 0; i--) {\n      const rep = replacements[i];\n      current_html =\n        current_html.substring(0, rep.start) +\n        rep.marker +\n        current_html.substring(rep.end);\n    }\n  }\n\n  return { html_with_markers: current_html, extracted_map: extracted_blocks }\n}\n\n/**\n * Re-insert ignored HTML blocks.\n * \n * @param {string} html_with_markers \n * @param {Map<any,any>} extracted_map \n * @returns \n */\nfunction reinsertIgnoredBlocks(html_with_markers, extracted_map) {\n  setState({ ignored: false });\n  let final_html = html_with_markers;\n\n  for (const [marker, original_block] of extracted_map) {\n    final_html = final_html.split(marker).join(original_block);\n  }\n  return final_html\n}\n\nconst void_element_regex = new RegExp(`<(${VOID_ELEMENTS.join(\"|\")})(?:\\\\s(?:[^/>]|/(?!>))*)*>`, 'g');\n\n/**\n * Add a placeholder for void elements that are not self-closing.\n * This is for internal processing only.\n * \n * @param {string} html \n * @returns \n */\nfunction setSelfClosing(html) {\n  const { constants } = getState();\n\n  return html.replace(\n    // match only void elements that are not self-closing\n    void_element_regex,\n    match => match.replace(/>$/, constants.SELF_CLOSING_PLACEHOLDER)\n  )\n}\n\n/**\n * Remove internal placeholder for non-native self-closing void elements.\n * \n * @param {string} html \n * @returns \n */\nfunction unsetSelfClosing(html) {\n  const { constants } = getState();\n\n  return html.replace(constants.SELF_CLOSING_PLACEHOLDER, \">\")\n}\n\n/**\n * Enforce entity characters for textarea content.\n * To also minifiy tags, pass `minify` as `true`.\n * \n * @param {string} html The HTML string to evaluate.\n * @param {boolean} [minify] Minifies the textarea tags themselves. \n * Defaults to `false`. We recommend a value of `true` if you're running `entify()` \n * as a standalone function.\n * @returns {string}\n * @example <textarea>3 > 2</textarea> => <textarea>3&nbsp;&gt;&nbsp;2</textarea>\n * @example With minify.\n * <textarea  >3 > 2</textarea> => <textarea>3&nbsp;&gt;&nbsp;2</textarea>\n */\nconst entify = (html, minify = false) => {\n  /** \n   * Use entities inside textarea content.\n   */\n  html = html.replace(/<\\s*textarea[^>]*>((.|\\n)*?)<s*\\/\\s*textarea\\s*>/g, (match, capture) => {\n    return match.replace(capture, (match) => {\n      return match\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&apos;')\n        .replace(/\\n/g, '&#10;')\n        .replace(/\\r/g, '&#13;')\n        .replace(/\\s/g, '&nbsp;')\n    })\n  });\n\n  if (minify) {\n    html = html.replace(/<\\s*textarea[^>]*>(.|\\n)*?<\\s*\\/\\s*textarea\\s*>/g, (match) => {\n      /* This only affects the html tags, since everything else has been entified. */\n      return match\n        .replace(/\\s+/g, ' ')\n        .replace(/\\s>/g, '>')\n        .replace(/>\\s/g, '>')\n        .replace(/\\s</g, '<')\n        .replace(/<\\s/g, '<')\n        .replace(/<\\/\\s/g, '<\\/')\n        .replace(/class=[\"']\\s/g, (match) => match.replace(/\\s/g, ''))\n        .replace(/(class=.*)\\s([\"'])/g, '$1'+'$2')\n    });\n  }\n\n  return html\n};\n\n/**\n * Remove entity characters for textarea content.\n * Currently internal use only.\n * \n * @param {string} html The HTML string to evaluate.\n * @returns {string}\n * @example <textarea>3&nbsp;&gt;&nbsp;2</textarea> => <textarea>3 > 2</textarea>\n */\nconst dentify = (html) => {\n  /** \n   * Remove entities inside textarea content.\n   */\n  return html = html.replace(/<textarea[^>]*>((.|\\n)*?)<\\/textarea>/g, (match, capture) => {\n    return match.replace(capture, (match) => {\n      match = match\n        .replace(/&lt;/g, '<')\n        .replace(/&gt;/g, '>')\n        .replace(/&quot;/g, '\"')\n        .replace(/&apos;/g, \"'\")\n        .replace(/&#10;/g, '\\n')\n        .replace(/&#13;/g, '\\r')\n        .replace(/&nbsp;/g, ' ')\n        // Ensure we collapse consecutive spaces, or they'll be completely removed later.\n        .replace(/\\s+/g, ' ');\n\n      return match\n    })\n  })\n};\n\n/**\n * @type {Map<any,any>}\n */\nlet ignore_map$1;\n\n/**\n * Creates a single-line HTML string\n * by removing line returns, tabs, and relevant spaces.\n * \n * @param {string} html The HTML string to minify.\n * @param {import('htmlfy').UserConfig} [config] A user configuration object.\n * @returns {string} A minified HTML string.\n */\nconst minify = (html, config) => {\n  let reinsert_ignored = false;\n  const { checked_html, ignored, constants } = getState();\n\n  if (!checked_html && !isHtml(html)) return html\n\n  const validated_config = (getState()).config;\n  const ignore = validated_config.ignore.length > 0;\n\n  /* Extract ignored elements. Skipped if prettify has already ignored blocks. */\n  if (!ignored && ignore) {\n    const { html_with_markers, extracted_map } = extractIgnoredBlocks(html);\n    html = html_with_markers;\n    ignore_map$1 = extracted_map;\n    reinsert_ignored = true;\n  }\n\n  /**\n   * Ensure textarea content is protected\n   * before general minification.\n   */\n  html = entify(html, true);\n\n  /* All other minification. */\n  // Remove ALL newlines and tabs explicitly.\n  html = html.replace(/\\n|\\t/g, '');\n\n  // Remove whitespace ONLY between tags.\n  html = html.replace(/>\\s+</g, \"><\");\n\n  // Collapse any remaining multiple spaces to single spaces.\n  html = html.replace(/ {2,}/g, ' ');\n\n  // Protect space between text content and an opening tag (e.g., \"text <a>\")\n  html = html.replace(\n    /(\\S) (<[a-zA-Z][a-zA-Z0-9_:-]*)/g,\n    `$1___MINIFY-PROTECTED-SPACE___$2`\n  );\n\n  // Protect space between a closing tag and text content (e.g., \"</a> text\")\n  html = html.replace(\n    /(<\\/[a-zA-Z][a-zA-Z0-9_:-]*>) (\\S)/g,\n    `$1___MINIFY-PROTECTED-SPACE___$2`\n  );\n\n  // Remove specific single spaces between tags and whitespace within tags.\n  html = html.replace(/ >/g, \">\");   // <tag > -> <tag>\n  html = html.replace(/ </g, \"<\");   // leading space before tag\n  html = html.replace(/> /g, \">\");   // trailing space after tag\n  html = html.replace(/< /g, \"<\");   // < tag> -> <tag>\n  html = html.replace(/<\\s+\\//g, '</'); // < /tag> -> </tag>\n  html = html.replace(/<\\/\\s+/g, '</'); // </ tag> -> </tag>\n\n  // Unprotect space around inner tags\n  html = html.replace(new RegExp('___MINIFY-PROTECTED-SPACE___', 'g'), ' ');\n\n  // Trim spaces around equals signs in attributes (run before value trim)\n  //    This handles `attr = \"value\"` -> `attr=\"value\"`\n  html = html.replace(/ = /g, \"=\");\n  // Consider safer alternatives if needed (e.g., / = \"/g, '=\"')\n\n  // Trim whitespace inside attribute values\n  html = html.replace(\n    /([a-zA-Z0-9_-]+)=(['\"])(.*?)\\2/g,\n    (match, attr_name, quote, value) => {\n      // value.trim() handles both leading/trailing spaces\n      // and cases where the value is only whitespace (becomes empty string)\n      const trimmed_value = value.trim();\n      return `${attr_name}=${quote}${trimmed_value}${quote}`\n    }\n  );\n\n  // Final trim for the whole string\n  html = html.trim();\n\n  /* Remove protective entities. */\n  html = dentify(html);\n\n  /* Re-insert ignored elements. Skipped unless minify did the ignore. */\n  if (reinsert_ignored) {\n    html = reinsertIgnoredBlocks(html, ignore_map$1);\n  }\n\n  return html\n};\n\n/**\n * @type {{ line: Record<string,string>[] }}\n */\nconst convert = {\n  line: []\n};\n\n/**\n * @type {Map<any,any>}\n */\nlet ignore_map;\n\n/**\n * Isolate tags, content, and comments.\n * \n * @param {string} html The HTML string to evaluate.\n * @example <div>Hello World!</div> => \n *  [#-# : 0 : <div> : #-#]\n *  Hello World!\n *  [#-# : 1 : </div> : #-#]\n */\nconst enqueue = (html) => {\n  convert.line = [];\n  let i = -1;\n  /* Regex to find tags OR text content between tags. */\n  const regex = /(<[^>]+>)|([^<]+)/g;\n\n  html.replace(regex, (match, c1, c2) => {\n    if (c1) {\n      convert.line.push({ type: \"tag\", value: match });\n    } else if (c2 && c2.trim().length > 0) {\n      /* It's text content (and not just whitespace). */\n      convert.line.push({ type: \"text\", value: match });\n    }\n\n    i++;\n    return `\\n[#-# : ${i} : ${match} : #-#]\\n`\n  });\n};\n\n/**\n * Process enqueued content.\n *  \n * @returns {string}\n */\nconst process = () => {\n  const { config, constants } = getState();\n  const step = \" \".repeat(config.tab_size);\n  const tag_wrap = config.tag_wrap;\n  const content_wrap = config.content_wrap;\n  const strict = config.strict;\n\n  /* Track current number of indentations needed. */\n  let indents = '';\n\n  /** @type string[] */\n  const output_lines = [];\n  const tag_regex = /<[A-Za-z]+\\b[^>]*(?:.|\\n)*?\\/?>/g; /* Is opening tag or void element. */\n  const attribute_regex = /\\s{1}[A-Za-z-]+(?:=\".*?\")?/g; /* Matches all tag/element attributes. */\n\n  /* Process lines and indent. */\n  convert.line.forEach((source, index) => {\n    let current_line_value = source.value;\n\n    const is_ignored_content =\n      current_line_value.startsWith('___HTMLFY_SPECIAL_IGNORE_MARKER_');\n\n    let subtrahend = 0;\n    const prev_line_data = convert.line[index - 1];\n    const prev_line_value = prev_line_data?.value ?? \"\"; // Use empty string if no prev line\n\n    /**\n     * Arbitratry character, to keep track of the string's length.\n     */\n    indents += '0';\n\n    if (index === 0) subtrahend++;\n    /* We're processing a closing tag. */\n    if (current_line_value.trim().startsWith(\"</\")) subtrahend++;\n    /* prevLine is a doctype declaration. */\n    if (prev_line_value.trim().startsWith(\"<!doctype\")) subtrahend++;\n    /* prevLine is a comment. */\n    if (prev_line_value.trim().startsWith(\"<!--\")) subtrahend++;\n    /* prevLine is a void element. */\n    if (\n      prev_line_value.trim().endsWith(\"/>\") // native self-closing\n      ||\n      prev_line_value.trim().endsWith(constants.SELF_CLOSING_PLACEHOLDER) // synthetic self-closing\n    ) subtrahend++;\n    /* prevLine is a closing tag. */\n    if (prev_line_value.trim().startsWith(\"</\")) subtrahend++;\n    /* prevLine is text. */\n    if (prev_line_data?.type === \"text\") subtrahend++;\n\n    /* Determine offset for line indentation. */\n    const offset = Math.max(0, indents.length - subtrahend);\n    /* Correct indent level for *this* line's content */\n    const current_indent_level = offset; // Store the level for this line\n\n    indents = indents.substring(0, current_indent_level); // Adjust for *next* round\n\n    /**\n     * Starts with a single punctuation character.\n     * Add punctuation to end of previous line.\n     */\n    if (source.type === 'text' && /^[!,;\\.]/.test(current_line_value)) {\n      if (current_line_value.length === 1) {\n        output_lines[output_lines.length - 1] = \n          output_lines.at(-1) + current_line_value;\n        return\n      } else {\n        output_lines[output_lines.length - 1] = \n          output_lines.at(-1) + current_line_value.charAt(0);\n        current_line_value = current_line_value.slice(1).trim();\n\n        /* If nothing left after extracting punctuation, skip this line. */\n        if (current_line_value.length === 0) return\n      }\n    }\n\n    const padding = step.repeat(current_indent_level);\n\n    if (is_ignored_content) {\n      /* Stop processing this line, as it's set to be ignored. */\n      output_lines.push(current_line_value);\n    } else {\n      /* Remove comment. */\n      if (strict && current_line_value.trim().startsWith(\"<!--\"))\n        return\n\n      let result = current_line_value;\n\n      /* Remove self-closing placeholder, if needed. */\n      result = unsetSelfClosing(result);\n\n      if (\n        source.type === 'text' && \n        content_wrap > 0 && \n        result.length >= content_wrap\n      ) {\n        result = wordWrap(result, content_wrap, padding);\n      }\n      /* Wrap the attributes of open tags and void elements. */\n      else if (\n        tag_wrap > 0 &&\n        result.length > tag_wrap &&\n        tag_regex.test(result)\n      ) {\n        tag_regex.lastIndex = 0; // Reset stateful regex\n        attribute_regex.lastIndex = 0; // Reset stateful regex\n\n        const tag_parts = result.split(attribute_regex).filter(Boolean);\n\n        if (tag_parts.length >= 2) {\n          const attributes = result.matchAll(attribute_regex);\n          const inner_padding = padding + step;\n          let wrapped_tag = padding + tag_parts[0] + \"\\n\";\n\n          for (const a of attributes) {\n            const attribute_string = a[0].trim();\n            wrapped_tag += inner_padding + attribute_string + \"\\n\";\n          }\n\n          const tag_name_match = tag_parts[0].match(/<([A-Za-z_:-]+)/);\n          const tag_name = tag_name_match ? tag_name_match[1] : \"\";\n          const is_self_closing = tag_parts.at(-1)?.endsWith(\"/>\") && VOID_ELEMENTS.includes(tag_name);\n          const closing_part = tag_parts[1].trim();\n          const closing_padding = padding + (strict && is_self_closing ? \" \" : \"\");\n\n          wrapped_tag += closing_padding + closing_part;\n\n          result = wrapped_tag; // Assign the fully wrapped string\n        } else {\n          result = padding + result;\n        }\n      } else {\n        /* Apply simple indentation (if no wrapping occurred) */\n        result = padding + result;\n      }\n\n      /* Add the processed line (or lines if wordWrap creates them) to the output */\n      output_lines.push(result);\n    }\n  });\n\n  /* Join all processed lines into the final HTML string */\n  let final_html = output_lines.join(\"\\n\");\n\n  /* Preserve wrapped attributes. */\n  if (tag_wrap > 0) final_html = protectAttributes(final_html);\n\n  /* Extra preserve wrapped content. */\n  if (content_wrap > 0 && new RegExp(`/\\\\n[ ]*[^\\\\n]*${constants.CONTENT_IGNORE_PLACEHOLDER}[^\\\\n]*\\\\n/`).test(final_html))\n    final_html = finalProtectContent(final_html);\n\n  /* Remove line returns, tabs, and consecutive spaces within html elements or their content. */\n  final_html = final_html.replace(\n    /<(?<Element>[^>\\s]+)[^>]*>[^<]*?[^><\\/\\s][^<]*?<\\/\\k<Element>>|<script[^>]*>[\\s]*<\\/script>|<([\\w:\\._-]+)([^>]*)><\\/\\2>|<([\\w:\\._-]+)([^>]*)>[\\s]+<\\/\\4>/g,\n    match => {\n      // Check if this contains placeholder\n      if (match.includes(constants.SELF_CLOSING_PLACEHOLDER) || match.includes(constants.CONTENT_IGNORE_PLACEHOLDER)) {\n        return match // Don't modify if it contains the placeholder\n      }\n\n      return match.replace(/\\n|\\t|\\s{2,}/g, '')\n    }\n  );\n\n  /* Revert wrapped content. */\n  if (content_wrap > 0) final_html = unprotectContent(final_html);\n\n  /* Revert wrapped attributes. */\n  if (tag_wrap > 0) final_html = unprotectAttributes(final_html);\n\n  /* Remove self-closing nature of void elements. */\n  if (strict) final_html = final_html.replace(/\\s\\/>|\\/>/g, '>');\n\n  /* Trim leading and/or trailing line returns. */\n  if (final_html.startsWith(\"\\n\")) final_html = final_html.substring(1);\n  if (final_html.endsWith(\"\\n\")) final_html = final_html.substring(0, final_html.length - 1);\n\n  return final_html\n};\n\n/**\n * Format HTML with line returns and indentations.\n * \n * @param {string} html The HTML string to prettify.\n * @param {import('htmlfy').UserConfig} [config] A user configuration object.\n * @returns {string} A well-formed HTML string.\n */\nconst prettify = (html, config) => {\n  let reinsert_ignored = false;\n  const { checked_html, ignored } = getState();\n\n  /* Return content as-is if it does not contain any HTML elements. */\n  if (!checked_html && !isHtml(html)) return html\n\n  /* Runs setState for config. */\n  const validated_config = validateConfig(config || {});\n\n  const ignore = validated_config.ignore.length > 0;\n\n  /* Allows you to trimify before ignoring. */\n  if (validated_config.trim.length > 0) html = trimify(html, validated_config.trim);\n\n  /* Extract ignored elements. */\n  if (!ignored && ignore) {\n    const { html_with_markers, extracted_map } = extractIgnoredBlocks(html);\n    html = html_with_markers;\n    ignore_map = extracted_map;\n    reinsert_ignored = true;\n  }\n\n  /* Preserve html text within attribute values. */\n  html = setIgnoreAttribute(html);\n\n  /* Insert placeholder for void elements that aren't self-closing. */\n  html = setSelfClosing(html);\n\n  html = minify(html);\n  enqueue(html);\n  html = process();\n\n  /* Revert html text within attribute values. */\n  html = unsetIgnoreAttribute(html);\n\n  /* Re-insert ignored elements. */\n  if (reinsert_ignored) {\n    html = reinsertIgnoredBlocks(html, ignore_map);\n  }\n\n  return html\n};\n\n// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nexport { prettify as default };\n"],"names":["CONFIG","content_wrap","ignore","ignore_with","strict","tab_size","tag_wrap","trim","VOID_ELEMENTS","state","checked_html","config","ignored","constants","CONTENT_IGNORE_PLACEHOLDER","SELF_CLOSING_PLACEHOLDER","ATTRIBUTE_IGNORE_PLACEHOLDER","getState","setState","new_state","Object","assign","isHtml","content","test","mergeObjects","current","updates","Error","merged","Array","isArray","structuredClone","concat","key","keys","validateConfig","default_config","hasOwn","Number","isSafeInteger","Math","floor","_config$ignore","every","e","startsWith","_config$trim","validated_config","mergeConfig","wordWrap","text","width","indent","words","split","length","lines","current_line","padding_string","forEach","word","push","test_line","html","replace","protectContent","join","extractIgnoredBlocks","current_html","extracted_blocks","Map","marker_id","tag","safe_tag_name","regex","RegExp","match","replacements","exec","marker","set","start","index","end","i","rep","substring","html_with_markers","extracted_map","reinsertIgnoredBlocks","final_html","original_block","void_element_regex","ignore_map$1","convert","line","ignore_map","process","step","repeat","indents","output_lines","tag_regex","attribute_regex","source","current_line_value","value","is_ignored_content","subtrahend","prev_line_data","prev_line_value","endsWith","type","current_indent_level","max","at","charAt","slice","padding","result","unsetSelfClosing","lastIndex","tag_parts","filter","Boolean","attributes","matchAll","inner_padding","wrapped_tag","a","tag_name_match","tag_name","is_self_closing","includes","closing_part","capture","protectAttributes","p1","p2","p3","p4","text_to_protect","protected_text","finalProtectContent","unprotectContent","unprotectAttributes","reinsert_ignored","leading_whitespace","trailing_whitespace","trimify","minify","entify","dentify","attr_name","quote","setSelfClosing","setIgnoreAttribute","c1","c2","enqueue","escapedIgnoreString","ltPlaceholderRegex","gtPlaceholderRegex","fullMatch","tagName","attributesCapture","unsetIgnoreAttribute"],"mappings":"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"}